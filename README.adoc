// Copyright (c) 2017, 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
:projectid: docker
:page-layout: guide-multipane
:page-duration: 20 minutes
:page-description: Learn how to use Docker containers for iterative development. 
:page-releasedate: 2017-12-27
:page-tags: ['Docker']
:page-related-guides: ['rest-intro', 'containerize']
:page-guide-category: basic
:page-essential: true
:page-essential-order: 4
:page-permalink: /guides/{projectid}
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
:page-seo-title: Learn how to use Docker containers for iterative development 
:page-seo-description: A getting started tutorial with examples of how to run a simple RESTful Java microservice in a Docker container built from a Dockerfile.
:guide-author: Open Liberty
= Using Docker containers to develop microservices

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to use Docker containers for iterative development.

:linux: LINUX
:win: WINDOWS
:mac: MAC

// =================================================================================================
// Introduction
// =================================================================================================

== What you'll learn

You will learn how to set up, run, and iteratively develop a simple REST application in a container with Open Liberty and Docker.

Open Liberty is an application server designed for the cloud. It’s small, lightweight, and designed with modern cloud-native
application development in mind. Open Liberty simplifies the development process for these applications by automating 
the repetitive actions associated with running applications inside containers, like rebuilding the image and stopping and starting 
the container. 

You'll also learn how to create and run automated tests for your application and container.

The implementation of the REST application can be found in the
`start/src` directory. To learn more about this application and how to build it, check out the
https://openliberty.io/guides/rest-intro.html[Creating a RESTful web service^] guide.

=== What is Docker?

Docker is a tool that you can use to deploy and run applications with containers. You
can think of Docker like a virtual machine that runs various applications. However, unlike a typical virtual
machine, you can run these applications simultaneously on a single system and independent of
one another.

Learn more about Docker on the https://www.docker.com/what-docker[official Docker website^].

To install Docker, follow the instructions in the https://docs.docker.com/engine/installation[official Docker documentation^].

=== What is a container?

A container is a lightweight, stand-alone package that contains a piece of software that is bundled together
with the entire environment that it needs to run. Containers are small compared to regular images and can
run on any environment where Docker is set up. Moreover, you can run multiple containers on a single
machine at the same time in isolation from each other.

Learn more about containers on the https://www.docker.com/what-container[official Docker website^].

=== Why use a container to develop?

Consider a scenario where you need to deploy your application on another environment. Your application
works on your local machine, but when you try to run it on your cloud production environment, it breaks. You do
some debugging and discover that you built your application with Java 8, but this container environment has only 
Java 11 installed. Although this issue is generally easy to fix, you don't want your application to be missing 
dozens of version-specific dependencies. You can develop your application in this container environment, but that 
requires you to rebuild and repackage your application every time you update your code and wish to test it.

To avoid this kind of problem, you can instead choose to develop your application in a container locally, bundled together with the
entire environment that it needs to run. By doing this, you know that at any point in your iterative development process,
the application can run inside that container. This helps avoid any unpleasant surprises when you go to test or
deploy your application down the road. Containers are quick to run and do not have a major impact on the speed
of your iterative development. 

== Additional prerequisites

Before you begin, Docker needs to be installed. For installation instructions, refer to the https://docs.docker.com/get-docker/[official Docker documentation^]. You will build and run the application in Docker containers.

Make sure to start your Docker daemon before you proceed.

// =================================================================================================
// Getting started
// =================================================================================================
[role='command']
include::{common-includes}/gitclone.adoc[]

// =================================================================================================
// Creating the Dockerfile
// =================================================================================================

== Creating the Dockerfile

// File 0
Dockerfile
[source, text, linenums, role="code_column"]
----
include::finish/Dockerfile[]
----

// File 1
`.dockerignore`
[source, text, linenums, role="code_column"]
----
include::finish/.dockerignore[]
----

The first step to running your application inside of a Docker container is creating a Dockerfile.
A Dockerfile is a collection of instructions for building a Docker image that can then be run as a
container. Every Dockerfile begins with a parent or base image on top of which various commands
are run. For example, you can start your image from scratch and run commands that download and
install Java, or you can start from an image that already contains a Java installation.

Navigate to the `start` directory to begin.

[role="code_command hotspot file=0",subs="quotes"]
----
#Create the `Dockerfile`.#
`Dockerfile`
----

The [hotspot=from file=0]`FROM` instruction initializes a new build stage and indicates the parent image from which your
image is built. If you don't need a parent image, then use `FROM scratch`, which makes your image a
base image. 

In this case, you’re using the `openliberty/open-liberty:kernel-java8-openj9-ubi` image as your parent image, 
which comes with the latest Open Liberty runtime.

The [hotspot=copy file=0]`COPY` instructions are structured as `COPY` 
`[--chown=<user>:<group>]` `<source>` `<destination>`. 
They copy local files into the specified destination within your Docker image.
In this case, the server configuration file that is located at `src/main/liberty/config/server.xml` 
is copied to the `/config/` destination directory.

=== Optional: Writing a .dockerignore file

When Docker runs a build, it sends all of the files and directories that are located in the same directory
as the Dockerfile to its build context, making them available for use in instructions like `ADD` and `COPY`.
To make your image build faster, add all files and directories that aren't necessary for building your
image to a `.dockerignore` file. This excludes them from the build context.

A [hotspot file=1]`.dockerignore` file is available to you in the `start` directory. This file includes 
the `pom.xml` file and some system files. Feel free to add anything else that you want to exclude.

// =================================================================================================
// Launching Open Liberty in development mode  
// =================================================================================================

== Launching Open Liberty in development mode

The Open Liberty Maven plug-in includes a `devc` goal that builds a Docker image, mounts the required directories,
binds the required ports, and then runs the application inside of a container. This development mode will also listen for any 
changes in the application source code or configuration and will rebuild the image and restart the container as necessary.

Build and run the container by running the `devc` goal from the `start` directory:

[role='command']
```
mvn liberty:devc
```

After you see the following message, your application server in dev mode is ready:
[role="no_copy"]
----
************************************************************************
*    Liberty is running in dev mode.
----

Open another command-line session and run the following command to make sure that your
container is running and didn’t crash:

[role='command']
```
docker ps 
```

You should see something similar to the following output:

[role="no_copy"]
----
CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                                                                    NAMES
ee2daf0b33e1        guide-docker-dev-mode   "/opt/ol/helpers/run…"   2 minutes ago       Up 2 minutes        0.0.0.0:7777->7777/tcp, 0.0.0.0:9080->9080/tcp, 0.0.0.0:9443->9443/tcp   liberty-dev
----


To view a full list of all available containers, you can run the `docker ps -a` command.

If your container is running without problems, point your browser to http://localhost:9080/system/properties[http://localhost:9080/system/properties^] 
where you can see a JSON file that contains the system properties of the JVM in your container.

// =================================================================================================
// Updating the application while the container is running 
// =================================================================================================

== Updating the application while the container is running

// File 0 
PropertiesResource.java
[source, java, linenums, role='code_column hide_tags=comment']
----
include::finish/src/main/java/io/openliberty/guides/rest/PropertiesResource.java[]
----

With your container running, make the following update to the source code:

[role="code_command hotspot hotspot file=0", subs="quotes"]
----
#Update the `PropertiesResource` class.#
`src/main/java/io/openliberty/guides/rest/PropertiesResource.java`
----

[role="edit_command_text"]
Change the endpoint of your application from `properties` to `properties-new` by changing the [hotspot=Path]`@Path`
annotation to `"properties-new"`.

After you make the file changes, Open Liberty automatically updates the application. To see these changes reflected in the application, 
point your browser to http://localhost:9080/system/properties-new[http://localhost:9080/system/properties-new^].

// =================================================================================================
// Testing the container 
// =================================================================================================

== Testing the container 

// File 0
EndpointIT.java
[source, java, linenums, role='code_column hide_tags=comment']
----
include::finish/src/test/java/it/io/openliberty/guides/rest/EndpointIT.java[]
----

You could test this service manually by starting a server and pointing a web browser to the 
http://localhost:9080/system/properties-new[http://localhost:9080/system/properties-new^] URL. 
However, automated tests are a much better approach because they trigger a failure if a change introduces a bug.
JUnit and the JAX-RS Client API provide a simple environment to test the application. 
You can write tests for the individual units of code outside of a running application server, or they
can be written to call the application server directly. In this example, you will create a test that does the latter.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `EndpointIT` class.#
`src/test/java/it/io/openliberty/guides/rest/EndpointIT.java`
----

This test makes a request to the `/system/properties-new` endpoint and checks to
make sure that the response has a valid status code, and that the information in
the response is correct. 

[role='command']
include::{common-includes}/devmode-test.adoc[]

You will see the following output:

[source,role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.rest.EndpointIT
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.884 sec - in it.io.openliberty.guides.rest.EndpointIT

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
----

When you are finished, press `CTRL+C` in the session that the dev mode was started from. This will both stop and remove the container for you. 
You can check that the container was stopped by running the `docker ps` command.

// =================================================================================================
// Starting development mode with run options 
// =================================================================================================

== Starting development mode with run options

Another useful feature of development mode with a container is the ability to pass additional options
to the `docker run` command. You can do this by adding the `<dockerRunOpts>` tag to the `pom.xml` file under 
the `<configuration>` tag of the Liberty Maven Plugin. Here is an example of an environment variable 
being passed in:

[role="no_copy"]
----
<groupId>io.openliberty.tools</groupId>
<artifactId>liberty-maven-plugin</artifactId>
<version>3.3.2</version>
<configuration>
    <dockerRunOpts>-e ENV_VAR=exampleValue</dockerRunOpts>
</configuration>
----

If the Dockerfile isn't located in the directory that the `devc` goal is being
run from, you can add the `<dockerfile>` tag to specify the location. Note that
using this parameter will set the context for building the Docker image to the
directory that contains this file.

Additionally, both of these options can be passed from the command line when running the `devc` goal by
adding `-D` as such:

[role="no_copy"]
----
mvn liberty:devc \
-DdockerRunOpts="-e ENV_VAR=exampleValue" \
-Ddockerfile="./path/to/file"
----

To learn more about development mode with a container and its different
features, check out the  
https://github.com/OpenLiberty/ci.maven/blob/master/docs/dev.md#devc-container-mode[Documentation].